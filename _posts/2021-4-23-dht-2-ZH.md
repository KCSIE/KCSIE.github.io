---
title: 分布式哈希表 - 2 (Kademlia版本) - ZH
tags: DHT BitTorrent IPFS P2P Blockchain Network
---

# 关于Kademlia

Kademlia是由Petar Maymounkov和David Mazières在2002年设计的分布式哈希表，它在[《Kademlia: A Peer-to-peer information system based on the XOR Metric》](http://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)中被提出。它规定了网络的结构和通过节点查找进行的信息交互。Kademlia节点之间使用UDP进行通信，参与者的节点形成了一个虚拟或覆盖网络，每个节点都由一个数字或节点ID来识别。节点ID不仅可以作为标识，而且Kademlia算法使用节点ID来定位值（通常是文件哈希值或关键词）。事实上，节点ID提供了一个与文件哈希值的直接映射，该节点存储了在哪里获得文件或资源的信息。

当我们在网络中搜索某些值(即通常搜索存储文件散列或关键词的节点)的时候，Kademlia算法需要知道与这些值相关的键，然后分步在网络中开始搜索。每一步都会找到一些节点，这些节点的ID与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点ID的时候搜索便会停止。这种搜索值的方法是非常高效的，与其他的分散式杂凑表的实现类似，在一个包含n个节点的系统的值的搜索中，Kademlia仅访问O(log(n))个节点。

在后文中将Kademlia简称为Kad，同时具体实现将以Kad算法的一种BT协议中的Mainline DHT为例。



# 结构

## 关键词

### Node ID

在 P2P 网络中， 节点是通过唯一 ID 来进行标识的，在原始的 Kad 算法中，使用 160-bit 哈希空间来作为 Node ID。

Kademlia 中使用 SHA1 哈希来计算 Node ID，SHA1 是一个 160 bit 的哈希空间，整个 ID 长度是 160 个位， 也就是 20 个字节，这样可以容纳2^160个节点。IPFS 中都使用 SHA256 来计算 Node ID，ID 长度是 256 位的哈希空间， 也即 32 个字节。Ethereum 使用 SHA3，也是 256 位哈希空间， 32 字节。

### 距离

每个节点保存着自己附近节点的信息，在 Kademlia 中节点到节点的距离不是指物理距离，而是指通过异或运算得到的逻辑距离。

### 异或运算

异或运算即XOR，是一种位运算，用于计算两个节点之间距离的远近。把两个节点的 Node ID 进行 XOR 运算，XOR 的结果越小，表示距离越近，通常会结合前缀匹配来看。

XOR指异为真同为假，符号为⊕，具有如下特点：

- (A ⊕ B) == (B ⊕ A): XOR 符合“交换律”，具备对称性。A和B的距离从哪一个节点计算都是相同的，相比之下，Chord 的距离算法不对称。
- (A ⊕ A) == 0: 反身性，自己和自己的距离为零。
- (A ⊕ B) > 0: 两个不同的 key 之间的距离必大于零。
- (A ⊕ B) + (B ⊕ C) >= (A ⊕ C): 三角不等式, A经过B到C的距离总是大于A直接到C的距离。

比如：0010 ⊕ 0000 = 0010，0111 ⊕ 0010 = 0101。

对于每个节点，给的一个距离d， 至多有一个与其距离为d节点。这样Kademlia的拓扑结构是单向的， 单向性确保不管查找从哪个节点开始, 同一Key的所有查找都会沿着同一路径收敛。

### K桶

用一个K桶来保存与当前节点距离在某个范围内的所有节点列表，bucket0, bucket1, bucket2 ... bucketN 分别记录[1, 2), [2, 4), [4, 8), ... [2^i, 2^(i+1)) 范围内的节点列表。

### 路由表

路由表记录了所有K桶，每个K桶限制最多保存 k 个节点。

## 具体结构

### 二叉树

Kademlia 中，Kad把Node ID（Key）映射到一个二叉树，每一个Node ID（Key）都是这个二叉树的叶子。

映射规则：

- 将Node ID（Key）以二进制形式表示，然后从高位到低位依次处理
- 二进制的第 n 个位就对应了二叉树的第 n 层
- 如果该位是1，进入左子树，是0则进入右子树（人为约定，可以改变）
- 全部位都处理完后，这个 Node ID 就对应了二叉树上的某个叶子

### 距离与异或

Kademlia 中，根据当前节点的 Node ID 与它保存的其他 peer 节点 Node ID 的匹配的最多的前缀 bit 个数来构建一颗二叉树，这里前缀匹配的 bit 数也叫 LCP（Longest Common Prefix）。比如，当前节点为 1101，与 1000 的前缀匹配的最高位之后从第二位开始就不匹配了，其 LCP 就是 1。Kademlia 中根据 LCP 来划分子树。当前节点的每个 LCP 都是一个子树。也可以这么理解，如果两个节点共有的祖先节点少(高位相异)，它们的距离就远；反之，如果共有的祖先节点多(高位相同)，它们的距离就近。

假设当前节点 ID 是 0011，可以被划分为 LCP = 3（none/）, 2（0/）, 1（00/）, 0（001/） 一共 4 个子树：

[![RXD7Zt.md.png](https://z3.ax1x.com/2021/07/08/RXD7Zt.md.png)](https://imgtu.com/i/RXD7Zt)

对于任意一个给定节点，我们将二叉树从根节点开始不断向下分成一系列不包含该节点的子树。最高的子树由不包含该节点的二叉树的一半组成，下一个子树又由不包含该节点的剩余树的一半组成，以此类推。如果这个二叉树的高度为 m + 1, 我们最终会得到 m 个子树。

### K桶与路由表

每个子树就是一个K桶，对于 160 bit 空间的 Node ID 一共有160个子树即160个K桶（参数Keyspace = 160 bit）。每个K桶可以通过 XOR 的结果来索引。子树中包含的叶节点数量被设置为最多k个，k就是每个K桶可以存多少个节点（常为20，Mainline中为8）。

[![RXfT10.png](https://z3.ax1x.com/2021/07/08/RXfT10.png)](https://imgtu.com/i/RXfT10)

在每个子树中任取 k 个节点，形成 m 个K桶，这 m 个 k 桶就是 Kademlia 节点的路由表。我们定义最小子树中取得的节点为第 0 个 k 桶，次小的子树中取得的节点为第 1 个 k 桶，以此类推。对于每个 0⩽i<m，第 i 个K桶中节点与当前节点的距离总是在区间[2^i, 2^(i+1))之内。以 m = 3, k = 2 时节点 101 的K桶为例：

[![RX6vt0.md.png](https://z3.ax1x.com/2021/07/08/RX6vt0.md.png)](https://imgtu.com/i/RX6vt0)

再以下图为例：

[![RXRHCq.png](https://z3.ax1x.com/2021/07/08/RXRHCq.png)](https://imgtu.com/i/RXRHCq)

对于Node 0010，Node 0000存储过程如下：

- 距离 = 0010 ⊕ 0000 = 0010 = 2
- 距离在区间[2^i, 2^(i+1)) (i = 1)内，即2~3，所以Node 0000应放在K-bucket 1里

也可以通过LCP判断，看异或的结果的最高非零位：

- 0011和0010，前3位匹配，异或最高非零位为0，放在bucket0
- 0000/0001和0010，前2位匹配，异或最高非零位为1，放在bucket1
- 0100/0110/0101/0111和0010，前1位匹配，异或最高非零位为2，放在bucket2



# 算法

## 消息

Kademlia协议由四个 RPC 调用组成：PING, STORE, FIND_NODE, FIND_VALUE。

- PING消息---用来测试节点是否仍然在线
- STORE消息---在某个节点中存储一个键值对
- FIND_NODE消息---消息请求的接收者将返回自己桶中离请求键值最近的k个节点
- FIND_VALUE消息---与FIND_NODE一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。

每一个RPC消息中都包含一个发起者加入的随机值，这一点确保响应消息在收到的时候能够与前面发送的请求消息匹配并防止地址伪造。

更具体的实现可以参考Bittorrent的Mainline DHT中的KRPC协议，它是由bencode编码组成的一个简单的RPC结构，使用 UDP 报文发送。它包含3种消息类型：请求/回复/错误。以及四种请求：

- PING---用来测试节点是否仍然在线,辅助路由表的更新
- ANNOUNCE_PEER(STORE)---通知其他节点自己开始下载某个资源，`announce_peer`中会携带`get_peer`回应消息里的token
- FIND_NODE---用于查找某个节点,以获得其地址信息
- GET_PEERS(FIND_VALUE)---与通过资源的infohash获得资源对应的peer列表

## 查找节点

Kademlia中节点需要实现的最重要的过程就是根据一个节点 ID 找到与它最近的 k 个节点，这个过程就是节点的查找，其中主要使用递归完成。

前文提过节点的储存过程，与之相关的基础操作是 `FIND_NODE` 操作，它接受一个 Key 作为参数，返回当前节点所知道的 k 个距离这个 Key 最近的节点。基于K桶找到这 k 个最近的节点的过程如下：先求出这个 Key 与当前节点的距离 d；第 i 个K桶中节点与当前节点的距离在区间[2^i, 2^(i+1))内，这些区间不会互相重叠，d 落在的区间所属的K桶中的节点就是距离这个 Key 最近的节点。如果这个K桶中的节点不足 k 个, 则在后一个K桶中取节点补充，如果还不够就再在后一个K桶中取。如果这个节点所有的K桶中的节点数之和都不足 k 个，就返回它所知道的所有节点。

随后进行节点查找，给定一个 Key 找出整个网络中距离它最近的 k 个节点是一个递归过程：由查找需要的起始节点先从离目标节点 Node ID 最近的非空K桶中取出 α 个节点（如果K桶中节点不足 α 个，则从其他K桶中取满 α 个）。整个过程就是初始节点调用自己的 `FIND_NODE`，找到 k 个它所知的距离 Key 最近的节点。接下来我们在这 k 个节点中取 α 个最近的节点，同时请求它们为 Key 执行 `FIND_NODE`（α 为系统级常量, 用于设置同时请求个数）。

多说无益，下面看下具体的例子，其核心思想就是每一次找都找最接近的。假设Node ID 0010要寻找Node ID 1110，但在0010节点保存的路由表中的Bucket里没有储存1110节点。

1. 0010 ⊕ 1110 = 1101 = 12，在 [8,16) 区间即 0010 的bucket 3
2. 向 bucket 3 中的节点依次发出查询请求，先从其中最前的 8 即 0010 ⊕ 1010 = 1000开始（设置 α = 3，则可以同时询问3个节点）
3. 1010 ⊕ 1110 = 0100 = 4，在 [4,7) 区间即 1010 的bucket 2，若无记录，继续向 bucket 2 中的节点发出查询请求
4. 设置 α = 3，向1111、1100、1101同时查询。假设1101  ⊕ 1110 = 0011 = 3在 [2,4)区间有1110记录，那么就找到了1110节点
5. 整个节点查找过程是不断收敛的，复杂度是O(log(n))



## 路由表维护

### 二叉树拆分

对每一个节点，都可以按照自己的视角对整个二叉树进行拆分成最多160个子树。拆分的规则是：先从根节点开始，把不包含自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的第二层子树；以此类推，直到最后只剩下自己。对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的任何一个节点。

Mainline DHT中使用前缀树（Tire），但是与Trie树又稍微有所不同。在Trie树里插入一个key时，我们要比对key的每一个char和Trie里边路径，当不一致时，会立刻分裂成一个子树。但是Mainline DHT中，当不一致时，不会立刻分裂，而是有一个长度为k的bucket。分两种情况讨论：

- 如果bucket长度小于k，直接插入bucket即可
- 如果bucket长度大于或等于k，分两种情况讨论：
  - 第一种情况是当前的路径是该节点Node ID（注意不是要插入的key，是自己的Node ID）的前缀，那么就分裂，左右子树的key分别是0和1，并且把当前bucket中的节点根据他们的当前char值分到相应的子树的bucket里边。
  - 第二种情况是当前路径不是该节点Node ID的前缀，这种情况下，直接把这个key丢掉。

### 路由表演变

路由表是一棵叶子节点为K桶的二叉树，所有的K桶集合无重叠地覆盖了整个 160 bit 空间。路由表中的节点是按需动态分配的，初始状态下，节点 u 的路由表只有一个节点，一个K桶覆盖了整个 Node ID 空间。当 u 得到了一个新的相邻节点时，它将根据与新的相邻节点的距离，尝试将其插入到合适的K桶中。和上面子树拆分一样，插入的规则如下：

- 如果K桶未满，新的相邻节点就会被直接插入
- 如果K桶满了：
  - 如果K桶的范围包括了 u 自身的 Node ID，则K桶将会一分为二，原K桶中的 Node ID 重新分配到新的K桶中，然后再尝试插入
  - 如果K桶的范围不包括 u 自身的 Node ID，新的相邻节点将直接被丢弃
    - 高度不平衡的二叉树中可能产生问题，假设 u 是唯一一个 Node ID 以 000 开头的节点，同时有超过 k 个 ID 以 001 开头的节点 v1,v2…vk…vn。对于每个节点 v 的路由表，u 都将会被插入到一个空K桶中。u 的桶更新只会通知到 u 的路由表所记录的所有 v 中的 k 个。
    - 为了避免剩余的 v 无法得到 u 的桶更新信息，Kad中节点通过进行额外的拆分以保存了超过 k 个的所有有效的节点，哪怕不是因为K桶中包括了自身的 Node ID。

[![RzZeat.md.png](https://z3.ax1x.com/2021/07/09/RzZeat.md.png)](https://imgtu.com/i/RzZeat)

## K桶维护

### K桶更新

当一个节点收到任一来自其他节点的请求或者回复消息，它会根据发送者的节点 ID 更新K桶。规则如下：

- 每个bucket里的节点都按最后一次接触的时间倒序排列

- 如果发送节点已经存在接收方的K桶中：
  - 接收方将发送节点移动到相应K桶的尾部
- 如果发送节点不在接收方的K桶中：
  - 如果K桶中节点数量少于 k 个，则直接将发送节点插入至K桶尾部
  - 如果K桶已满：
    - 如果最近最少活跃节点不能 ping 通，则移除该节点，然后将发送节点插入至K桶尾部
    - 如果最近最少活跃节点可以 ping 通，则将该节点移动到尾部，然后丢弃发送节点

K桶遵循最近最少使用(Least Recently Used, LRU)淘汰算法，最近最少活跃的节点排在K桶的头部，最近最多活跃的节点排在K桶尾部，该机制保证了任意节点加入和离开都不影响整体网络。

### 加入网络

为了加入网络，一个节点 u 必须要与一个已存在在网络中的节点 w 有联系。u 将 w 插入到合适的K桶中，随后 u 对自己的 Node ID 进行一次节点查询，最后 u 会联系到离它邻居更远的节点，然后更新相应的K桶。在刷新过程中，u 构建自己的K桶同时也将自己插入到其他节点的K桶中。

节点加入时除了构建K桶之外，还应该取回这个节点应负责的资源。Kademlia中每隔一段时间，所有的节点都对其拥有的资源执行一次发布操作；此外每隔一段时间节点就会丢弃这段时间内未收到发布消息的资源。这样新节点就能收到自己须负责的资源，同时资源总能保持被 k 个距离它最近的节点负责。Kad的节点退出则不似Chord算法，由于具有K桶刷新和资源重发的机制，节点不需要做任何操作即可退出。

------

**Reference/参考**: 

1. [Distributed hash table](https://en.wikipedia.org/wiki/Distributed_hash_table)
2. [DHT 网络之 Kademlia 算法](https://0ranga.com/2018/11/08/dht-kademlia/)
3. [DHT 分布式哈希表](https://colobu.com/2018/03/26/distributed-hash-table/)
4. [易懂分布式 Kademlia算法](https://www.jianshu.com/p/f2c31e632f1d)
5. [P2P 网络核心技术：Kademlia 协议](https://zhuanlan.zhihu.com/p/40286711)
6. [DHT Protocol：BitTorrent DHT 协议中文翻译](https://justjavac.com/other/2015/02/01/bittorrent-dht-protocol.html)



