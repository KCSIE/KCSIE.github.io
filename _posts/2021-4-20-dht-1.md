---
title: Distributed Hash Table - 1 (Kademlia version)
tags: DHT BitTorrent IPFS P2P IPFS Blockchain Network
---

# Background



## P2P

### P2P Intro

P2P, also known as peer-to-peer technology, is a peer-to-peer network without a central server that relies on user group nodes for information exchange. Unlike the traditional C/S central server structure, each user node in a P2P network is both a client and a server, and can act as a server to provide services to other nodes. A P2P system is a self-organizing system in which each node is equal and autonomous, aiming to share the use of distributed resources in a network environment that avoids centralized services. One of the most important problems that the network needs to solve is how to find out on which node the resource requested by the user is located. This involves an iteration of P2P technology.

[![gDFNgx.md.png](https://z3.ax1x.com/2021/05/13/gDFNgx.md.png)](https://imgtu.com/i/gDFNgx)

### P2P Stage

The development phase of P2P is accompanied by a shift in the technical architecture. The first generation of P2P is a centralized peer-to-peer network with a centralized topology, where each child node needs to connect to the central server to find the resource since the index information of the file is stored on the central server, e.g. Napster. The second generation of P2P is an unstructured distributed network with a flooding search algorithm, which does not have a central server, e.g. Gnutella. The third generation of P2P is a structured distributed network, based on distributed hash tables.



## DHT

To implement a distributed network in a P2P system or distributed system, two core technologies need to be implemented.

- Topology and content routing
- Content delivery

DHT (Distributed Hash Table) is a distributed storage method proposed in the 1997 MIT paper [*Consistent Hashing and Random Trees：Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web*](https://www.akamai.com/us/en/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf). This distributed network does not require a central node server, instead each client is responsible for a small range of routes and for storing a small portion of the data, thus enabling the addressing and storage of the entire DHT network. DHT network also replicates backup redundant information on the nodes closest to the keywords, which avoids the single node failure problem. DHT is used to distribute a collection of key values (Key) to all nodes in the distributed system and can efficiently deliver the information to the only node (Peer) that has the key value provided by the query.

DHT has the following features:

- Decentralized: the nodes that make up the system do not have any centralized coordination mechanism
- Scale: The system should remain efficient even with a large number of nodes
- Fault tolerance: The system must be reliable even if nodes are constantly joining, leaving or stopping.

DHT specifies its own architecture, including Keyspace and Overlay Network, but does not specify the details of the algorithm, so there are many different implementations, such as Chord, Pastry, Kademlia, etc. The DHT in BitTorrent is based on a variation of Kademlia, called Mainline DHT. However, whether it is Chord, Pastry, or Kademlia, the most immediate goal is to locate the desired node as fast as possible. In P2P file sharing applications, the goal is to find the list of peers that are sharing a file/seed as fast as possible.

We will discuss DHT in detail later.



## BitTorrent & IPFS

### BitTorrent

BitTorrent (abbreviated to BT) is a communication protocol for peer-to-peer file sharing (P2P), which enables users to distribute data and electronic files over the Internet in a decentralized manner. BitTorrent protocol finds users with files other users want and then downloads pieces of the files from those users simultaneously. Consequently, transmission rates are faster than with http and ftp, which both download files sequentially from only one source.

The first release of the BitTorrent client had no search engine and no peer exchange, so users who wanted to upload a file had to create a small torrent descriptor file that they would upload to a torrent index site. The first uploader acted as a seed, and downloaders would initially connect as peers. Those who wish to download the file would download the torrent, which their client would use to connect to a tracker which had a list of the IP addresses of other seeds and peers in the swarm. Once a peer completed a download of the complete file, it could in turn function as a seed.

To solve the Tracker limitation, BitTorrent later uses DHT to store contact information between peers for seeds without Tracker, so that each peer becomes a tracker. However, two points need to be noted:

- A "peer" is a client/server listening on a TCP port that implements the BitTorrent protocol. 
- A "node" is a client/server listening on a UDP port implementing the distributed hash table protocol. 

### IPFS

InterPlanetary File System (IPFS) is a distributed, new hypermedia transport protocol based on content addressing. IPFS supports the creation of fully distributed applications. It is designed to make the network faster, more secure, and more open. IPFS is also a distributed file system, and its goal is to connect all computing devices to the same file system, thus becoming a globally unified storage system. By integrating existing technologies (BitTorrent, DHT/Kademlia, Git, and SFS), the IPFS project seeks to create a faster, more secure, and open next-generation Internet, enabling a global file storage system that is permanently available in the Internet and where data can be stored forever.

IPFS works as follows:

- Each file and all blocks within it are given a unique authentication code called a cryptographic hash.
- IPFS removes duplicate files with the same hash value over the network, and by calculating it is possible to determine which files are redundant duplicates. And the version history of each file is tracked.
- Each network node stores only what it is interested in, as well as some index information that helps figure out who is storing what.
- When looking for a file, you can look up the node storing the changed file in the network by the file's hash value and find the desired file.
- Using what is called IPNS (decentralized naming system), each file can be collaboratively named to an easy-to-read name. By searching, it is easy to find the file you want to view.





# 背景



## P2P

### P2P 简介

P2P是peer-to-peer的简称，又称为点对点技术，是没有中心服务器、依靠用户群节点进行信息交换的对等网络。区别于传统的C/S中央服务器结构，P2P网络中每一个用户节点即是客户端又是服务端，能同时作为服务器给其他节点提供服务。一个P2P系统是每个节点都是平等，自主的一个自我组织的系统，目的是在避免中心服务的网络环境中共享使用分布式资源。网络需要解决的一个最重要的问题就是如何知道用户请求的资源位于哪个节点上，这涉及了P2P技术的迭代。

[![gDFNgx.md.png](https://z3.ax1x.com/2021/05/13/gDFNgx.md.png)](https://imgtu.com/i/gDFNgx)

### P2P 阶段

P2P的发展阶段伴随的是技术架构的转变。第一代P2P是集中式对等网络，采用的是中心化的拓扑结构，由于文件的索引信息都是存储在中央服务器上，每个子节点都需要连接中央服务器才可以找到资源，如Napster。第二代P2P是非结构化的分布式网络，采用了泛洪搜索算法，它不设置中央服务器当用户请求资源时，它会请求它所有的邻接节点，邻接节点再依次请求各自的邻接节点，并使用一些策略防止重复请求直到找到拥有资源的节点，如Gnutella。第三代P2P便是结构化的分布式网络，基于分布式哈希表实现。



## DHT简介

在P2P系统或者分布式系统中，要实现一个分布式网络，需要实现两个核心的技术：

- 拓扑结构与内容路由
- 内容传送

目前来看P2P主流的内容路由实现方式便是DHT。DHT(Distributed Hash Table, 分布式哈希表)是是一种分布式存储方法，由1997年的MIT[《Consistent Hashing and Random Trees：Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》](https://www.akamai.com/us/en/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf)一文提出。这种分布式网络不需要中心节点服务器，而是每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。DHT网络还在于关键字最接近的节点上复制备份冗余信息，避免了单一节点失效问题。DHT用来将一个关键值(Key)的集合分散到所有分布式系统中的节点，并且可以有效地将信息转送到唯一一个拥有查询提供的关键值的节点(Peer)。

DHT具有如下特点：

- 分散性： 构成系统的节点并没有任何中央式的协调机制
- 规模性： 即使拥有众多节点，系统仍应保持效率
- 容错性： 即使节点不断地加入、离开或是停止工作，系统仍需达到一定可靠

它规定了自己的架构，包括Keyspace和Overlay Network（覆盖网络）两部分，但没有规定具体的算法细节，所以出现了很多不同的实现方式，比如Chord，Pastry，Kademlia等。BitTorrent中的DHT是基于Kademlia的一种变形，称为Mainline DHT。不过，不论是Chord, Pastry还是Kademlia，其最直接的目标就是以最快的速度来定位到期望的节点，在P2P文件分享应用中则是以最快的速度来查找到正在分享某一文件/种子的peers列表信息。

我们将在后面详细讨论DHT。



## BitTorrent & IPFS 协议

### BitTorrent 协议

BitTorrent协议（简称BT，俗称比特洪流）是用在对等网络中文件分享的网络协议程序。基于P2P模式的BT协议把文件分成很多小块，让下载者互相连接，每个下载者维护这个文件的某个小块，交换彼此下载好的部分，参与的人越多，互相交换的就越密集，下载速度越快。

根据BitTorrent协议，文件发布者会根据要发布的文件生成提供一个.torrent文件，即种子文件，也简称为“种子”。种子文件本质上是文本文件，包含Tracker信息和文件信息两部分。Tracker信息主要是BT下载中需要用到的Tracker服务器的地址和针对Tracker服务器的设置，文件信息是根据对目标文件的计算生成的，计算结果根据BitTorrent协议内的Bencode规则进行编码。它的主要原理是需要把提供下载的文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和Hash验证码写入种子文件中；所以，种子文件就是被下载文件的“索引”。

下载者要下载文件内容，需要先得到相应的种子文件，然后使用BT客户端软件进行下载。下载时，BT客户端首先解析种子文件得到Tracker地址，然后连接Tracker服务器。Tracker服务器回应下载者的请求，提供下载者其他下载者（包括发布者）的IP。下载者再连接其他下载者，根据种子文件，两者分别告知对方自己已经有的块，然后交换对方所没有的数据。此时不需要其他服务器参与，分散了单个线路上的数据流量，因此减轻了服务器负担。下载者每得到一个块，需要算出下载块的Hash验证码与种子文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容准确性的问题。

为了解决Tracker的制衡，BitTorrent后来使用DHT来为无 Tracker 的种子存储 peer之间的联系信息，这样每个peer都成了 tracker，这是基于 Kademila的DHT网络并且在 UDP上实现。不过需要注意一下两点：

- “peer” 是在一个 TCP 端口上监听的客户端/服务器，它实现了 BitTorrent 协议
- “node” 是在一个 UDP 端口上监听的客户端/服务器，它实现了 DHT协议

### IPFS 协议

星际文件系统（InterPlanetary File System，简称IPFS）是一个基于内容寻址的、分布式的、新型超媒体传输协议。IPFS支持创建完全分布式的应用。它旨在使网络更快、更安全、更开放。IPFS是一个分布式文件系统，它的目标是将所有计算设备连接到同一个文件系统，从而成为一个全球统一的存储系统。IPFS项目通过整合已有的技术（BitTorrent、DHT/Kademlia、Git和SFS），创建一种P2P超媒体协议，试图打造一个更加快速、安全、开放的下一代互联网，实现互联网中永久可用、数据可以永久保存的全球文件存储系统。IPFS工作原理如下：

- 每个文件及其中的所有块都被赋予一个称为加密散列的唯一指纹。
- IPFS通过网络删除重复具有相同哈希值的文件，通过计算是可以判断哪些文件是冗余重复的。并跟踪每个文件的版本历史记录。
- 每个网络节点只存储它感兴趣的内容，以及一些索引信息，有助于弄清楚谁在存储什么。
- 查找文件时，你通过文件的哈希值就可以在网络查找到储存改文件的节点，找到想要的文件。
- 使用称为IPNS（去中心化命名系统），每个文件都可以被协作命名为易读的名字。通过搜索，就能很容易地找到想要查看的文件。





# Distributed Hash Table



## From Hash Table to Distributed Hash Table

### Hash Table

A hash table, is a data structure that is accessed directly based on the Key value. That is, it accesses the records by mapping the keycode values to a location in the table to speed up the lookup process. This mapping function is called a hash function, and the array that holds the records is called a hash table. In a data structure like a hash table, it will contain N Buckets. For a specific hash table, N (the number of buckets) is usually fixed, so each bucket can be numbered from 0 to N-1. Buckets are used to store key-value pairs, which can be understood as a dynamic array that can hold multiple key-value pairs.

The process can be briefly described as follows, using Hash Table and Hash Function to map Key and Data (i.e. Value) into a Hash Bucket.

- After the Key passes through the Hash Function, the Bucket position is calculated, and then the Data is stored in the Bucket.
- After that, the Bucket location can be obtained within O(1) by using the same Key.

[![gDiESx.png](https://z3.ax1x.com/2021/05/13/gDiESx.png)](https://imgtu.com/i/gDiESx)

### DHT

The concept of DHT is to instantiate the above Bucket into individual storage nodes, where the distributed features are reflected.

- The Key is calculated after Hash Function to find out which node the Data should be stored in.
- The requests and data can be distributed to different nodes.

[![gDiVl6.png](https://z3.ax1x.com/2021/05/13/gDiVl6.png)](https://imgtu.com/i/gDiVl6)



## DHT Detail

The structure of a distributed hash table can be divided into several main components. The basis is an abstract `Keyspace`, for example a collection of all 160-bit long strings. `Keyspace Partitioning` splits the `Keyspace` into several nodes, which are assigned to nodes in this system. The extension network connects these nodes and allows them to find the node that has a value in the `Keyspace` by using any value in the `Keyspace`.

Suppose the `Keyspace` is a 160-bit long string collection. To store a file in a distributed hash table with the name `filename` and the content `data`, we compute the SHA-1 hash of `filename` - a 160-bit `key` - and send the message `put(key,data)` to any participating node in the distributed hash table. This message is routed through the extended network until it reaches the node designated to store the key value `key` in the key space partition. And `(key,data)` is stored in that node. Other nodes simply recompute the hash value `key` of `filename` and submit the message `get(key)` to any participating node in the distributed hash table to find the data associated with `key`. This message is also routed in the extended network to the node responsible for storing `key`. This node is then responsible for passing back the stored `data`.

[![gDFng0.png](https://z3.ax1x.com/2021/05/13/gDFng0.png)](https://imgtu.com/i/gDFng0)

### Address Management

As mentioned above, in the distributed hash table, each node and resource has a unique identifier, which is usually a 160-bit integer. For convenience, we call the unique identifier of a node ID and the unique identifier of a resource Key, and we can hash the IP address of a node with SHA-1 algorithm to get the ID of the node; similarly, we can hash a resource file with SHA-1 algorithm to get the Key of the resource. Once the ID and Key are defined, the resources can be published and stored. Each node is responsible for a specific range of Keys, and the rules depend on the specific algorithm.

There are two approaches to publishing and requesting resources: one is to transfer the file directly to the responsible node, which stores the file resource; when the resource is requested, the node then transfers the file to the requester. The other approach is that the publisher itself tries to store the resources, and transmits the address of the node where the file is located to the responsible node when publishing the file, and the responsible node stores only one address; when requesting resources, it contacts the responsible node to get the address of the resource file, and then retrieves the resources.

### Routing algorithms

#### Topology Design

DHT is an implementation of a distributed system that necessarily defines some kind of topology and therefore designs the routing algorithm. When a distributed system has its own topology, it becomes an overlay network itself. An overlay network is, in simple terms, a "network on top of a network". For most DHT, they are overlay networks on top of the Internet, and their data communication is dependent on the lower Internet for implementation. The node ID mentioned earlier are reflected in the fact that distributed systems only need to consider the node ID when designing topologies and routing algorithms, without considering the properties of the underlying network (e.g., protocol type, IP address, port number).

#### Routing Algorithm Implementation

First of all each node will be contacted by several other nodes (IP address, port), called routing table. In general a distributed hash table with n nodes has a routing table of O(logn) length. Each node constructs a routing table according to specific rules, and eventually all nodes form a network. A message from a node will gradually approach the target node along the network and finally reach the target node according to the specific routing rules. In a distributed hash table with n nodes, the number of times this process is forwarded is typically O(logn).

#### Distance Algorithm

Some DHT systems also define a distance algorithm to calculate: "distance between nodes", "distance between data", "distance between nodes and data". The "distance" here is logical and corresponds to the topology of the DHT itself, which is independent of the physical geographical location and the topology of the Internet.

### Self-organization

The nodes in the distributed hash table are composed of individual users, who join, leave or fail at any time; and there is no central server for the distributed hash table, which means that the system is completely unmanaged. This means that assigning addresses, constructing routing tables, joining nodes, leaving nodes, and excluding failed nodes all rely on self-organizing policies.

To publish or acquire resources, a node must first join, and there are usually several steps for a node to join. First, a new node needs to contact any existing node in the distributed hash table through some external mechanism. Then the new node constructs its own routing table by requesting this existing node and updates the routing table of other nodes that need to be connected to it. Finally the node also needs to retrieve the resources it is responsible for.





# 分布式哈希表



## 从哈希表到分布式哈希表

### 哈希表

哈希表（Hash Table，也叫散列表），是根据关键码值而直接进行访问的数据结构。也就是说它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。在散列表这种数据结构中，会包含 N 个 Bucket（桶）。对于某个具体的散列表，N（桶的数量）通常是固定不变的，于是可以对每个桶进行编号，从 0 到 N-1。桶是用来存储键值对的，可以把它通俗理解成一个动态数组，里面可以存放多个键值对。

过程简述为，利用Hash Table和Hash Function将Key和Data(即Value)映射到Hash Bucket中：

- Key经过Hash Function后算出Bucket位置，再Data存入
- 之后透过相同的Key可以在O(1)内得出Bucket位置

[![gDiESx.png](https://z3.ax1x.com/2021/05/13/gDiESx.png)](https://imgtu.com/i/gDiESx)

### 分布式哈希表

DHT的概念便是把上述的Bucket实例化为各个存储节点，此时分布式的特征在此体现。

- Key经过Hash Function后算出Data应该存储在哪个结点
- 流量请求和Data可以被分散至不同的结点上

[![gDiVl6.png](https://z3.ax1x.com/2021/05/13/gDiVl6.png)](https://imgtu.com/i/gDiVl6)



## DHT详解

分布式散列表的结构可以分成几个主要的组件。其基础是一个抽象的`键空间`（Keyspace），例如说所有160位长的字符串集合。`键空间分区`（Keyspace partitioning）将`键空间`分区成数个，并指定到在此系统的节点中。而`延展网络`则连接这些节点，并让他们能够借由在`键空间`内的任一值找到拥有该值的节点。

假设`键空间`是一个160位长的字符串集合。为了在分布式散列表中存储一个文件，名称为`filename`且内容为`data`，我们计算出`filename`的SHA-1散列值——一个160位的键`key`——并将消息`put(key,data)`送给分布式散列表中的任意参与节点。此消息在延展网络中被路由，直到抵达在键空间分区中被指定负责存储关键值`key`的节点。而`(key,data)`即存储在该节点。其他的节点只需要重新计算`filename`的散列值`key`，然后提交消息`get(key)`给分布式哈希表中的任意参与节点，以此来找与`key`相关的数据。此消息也会在延展网络中被路由到负责存储`key`的节点。而此节点则会负责传回存储的数据`data`。

[![gDFng0.png](https://z3.ax1x.com/2021/05/13/gDFng0.png)](https://imgtu.com/i/gDFng0)

### 地址管理

上文提到，在分布式哈希表中，每个节点和资源都有一个唯一标识，通常是一个 160 位整数。为方便起见，我们称节点的唯一标识为 ID，称资源的唯一标识为 Key。我们可以把一个节点的 IP 地址用 SHA-1 算法哈希得到这个节点的 ID；同样地，把一个资源文件用 SHA-1 算法哈希就能得到这个资源的 Key 了。定义好 ID 和 Key 之后，就可以发布和存储资源了。每个节点都会负责一段特定范围的 Key，其规则取决于具体的算法。

发布和请求资源有两种做法，一种是直接把文件传输给负责的节点，由它存储文件资源；请求资源时再由这个节点将文件传输给请求者。另一种做法是由发布者自己设法存储资源，发布文件时把文件所在节点的地址传输给负责的节点，负责的节点仅存储一个地址；请求资源的时候会联系负责的节点获取资源文件的地址，然后再取回资源。

### 路由算法

#### 拓扑结构设计

DHT是分布式系统的实现，必然要定义某种拓扑结构，因此要设计路由算法。当某个分布式系统具有自己的拓扑结构，它本身成为一个覆盖网络。覆盖网络，通俗地说就是“网络之上的网络”。对于大部分 DHT 而言，它们是基于互联网之上的覆盖网络，它们的数据通讯是依赖下层的互联网来实现的。前面提到的结点ID，体现在分布式系统在设计拓扑结构和路由算法时，只需要考虑结点ID，而不用考虑其下层网络的属性（比如：协议类型、IP 地址、端口号）。

#### 路由算法实现

首先每个节点会由若干个其他节点的联系方式(IP 地址, 端口)，称之为路由表。一般来说一个有着 n个节点的分布式哈希表中，一个节点的路由表的长度为O(log⁡n)。每个节点都会按照特定的规则构建路由表，最终所有的节点会形成一张网络。从一个节点发出的消息会根据特定的路由规则，沿着网络逐步接近目标节点，最终达到目标节点。在有着 n 个节点的分布式哈希表中，这个过程的转发次数通常为O(log⁡n) 次。

#### 距离算法

某些 DHT 系统还会定义一种距离算法，用来计算：“节点之间的距离”、“数据之间的距离”、“节点与数据的距离”。此处所说的“距离”属于逻辑层面，对应的是 DHT 自己的拓扑结构，它与物理上的地理位置无关，也与互联网的拓扑结构无关。

### 自我组织

分布式哈希表中的节点都是由各个用户组成，随时有用户加入，离开或失效；并且分布式哈希表没有中央服务器，也就是说着这个系统完全没有管理者。这意味着分配地址，构建路由表、节点加入、节点离开，排除失效节点等操作都要靠自我组织策略实现。

要发布或获取资源首先要有节点加入，一个节点加入通常有以下几步。首先，一个新节点需要通过一些外部机制联系分布式哈希表中的任意一个已有节点；接着新节点通过请求这个已有节点构造出自己的路由表，并且更新其他需要与其建立连接的节点的路由表；最后这个节点还需要取回它所负责的资源。