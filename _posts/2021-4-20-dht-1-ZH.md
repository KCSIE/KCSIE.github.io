---
title: 分布式哈希表 - 1 (Kademlia版本) - ZH
tags: DHT BitTorrent IPFS P2P Blockchain Network
---

# 背景

## P2P

### P2P 简介

P2P是peer-to-peer的简称，又称为点对点技术，是没有中心服务器、依靠用户群节点进行信息交换的对等网络。区别于传统的C/S中央服务器结构，P2P网络中每一个用户节点即是客户端又是服务端，能同时作为服务器给其他节点提供服务。一个P2P系统是每个节点都是平等，自主的一个自我组织的系统，目的是在避免中心服务的网络环境中共享使用分布式资源。网络需要解决的一个最重要的问题就是如何知道用户请求的资源位于哪个节点上，这涉及了P2P技术的迭代。

[![gDFNgx.md.png](https://z3.ax1x.com/2021/05/13/gDFNgx.md.png)](https://imgtu.com/i/gDFNgx)

### P2P 阶段

P2P的发展阶段伴随的是技术架构的转变。第一代P2P是集中式对等网络，采用的是中心化的拓扑结构，由于文件的索引信息都是存储在中央服务器上，每个子节点都需要连接中央服务器才可以找到资源，如Napster。第二代P2P是非结构化的分布式网络，采用了泛洪搜索算法，它不设置中央服务器当用户请求资源时，它会请求它所有的邻接节点，邻接节点再依次请求各自的邻接节点，并使用一些策略防止重复请求直到找到拥有资源的节点，如Gnutella。第三代P2P便是结构化的分布式网络，基于分布式哈希表实现。



## DHT简介

在P2P系统或者分布式系统中，要实现一个分布式网络，需要实现两个核心的技术：

- 拓扑结构与内容路由
- 内容传送

目前来看P2P主流的内容路由实现方式便是DHT。DHT(Distributed Hash Table, 分布式哈希表)是是一种分布式存储方法，由1997年的MIT[《Consistent Hashing and Random Trees：Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》](https://www.akamai.com/us/en/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf)一文提出。这种分布式网络不需要中心节点服务器，而是每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。DHT网络还在于关键字最接近的节点上复制备份冗余信息，避免了单一节点失效问题。DHT用来将一个关键值(Key)的集合分散到所有分布式系统中的节点，并且可以有效地将信息转送到唯一一个拥有查询提供的关键值的节点(Peer)。

DHT具有如下特点：

- 分散性： 构成系统的节点并没有任何中央式的协调机制
- 规模性： 即使拥有众多节点，系统仍应保持效率
- 容错性： 即使节点不断地加入、离开或是停止工作，系统仍需达到一定可靠

它规定了自己的架构，包括Keyspace和Overlay Network（覆盖网络）两部分，但没有规定具体的算法细节，所以出现了很多不同的实现方式，比如Chord，Pastry，Kademlia等。BitTorrent中的DHT是基于Kademlia的一种变形，称为Mainline DHT。不过，不论是Chord, Pastry还是Kademlia，其最直接的目标就是以最快的速度来定位到期望的节点，在P2P文件分享应用中则是以最快的速度来查找到正在分享某一文件/种子的peers列表信息。

我们将在后面详细讨论DHT。



## BitTorrent & IPFS 协议

### BitTorrent 协议

BitTorrent协议（简称BT，俗称比特洪流）是用在对等网络中文件分享的网络协议程序。基于P2P模式的BT协议把文件分成很多小块，让下载者互相连接，每个下载者维护这个文件的某个小块，交换彼此下载好的部分，参与的人越多，互相交换的就越密集，下载速度越快。

根据BitTorrent协议，文件发布者会根据要发布的文件生成提供一个.torrent文件，即种子文件，也简称为“种子”。种子文件本质上是文本文件，包含Tracker信息和文件信息两部分。Tracker信息主要是BT下载中需要用到的Tracker服务器的地址和针对Tracker服务器的设置，文件信息是根据对目标文件的计算生成的，计算结果根据BitTorrent协议内的Bencode规则进行编码。它的主要原理是需要把提供下载的文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和Hash验证码写入种子文件中；所以，种子文件就是被下载文件的“索引”。

下载者要下载文件内容，需要先得到相应的种子文件，然后使用BT客户端软件进行下载。下载时，BT客户端首先解析种子文件得到Tracker地址，然后连接Tracker服务器。Tracker服务器回应下载者的请求，提供下载者其他下载者（包括发布者）的IP。下载者再连接其他下载者，根据种子文件，两者分别告知对方自己已经有的块，然后交换对方所没有的数据。此时不需要其他服务器参与，分散了单个线路上的数据流量，因此减轻了服务器负担。下载者每得到一个块，需要算出下载块的Hash验证码与种子文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容准确性的问题。

为了解决Tracker的制衡，BitTorrent后来使用DHT来为无 Tracker 的种子存储 peer之间的联系信息，这样每个peer都成了 tracker，这是基于 Kademila的DHT网络并且在 UDP上实现。不过需要注意一下两点：

- “peer” 是在一个 TCP 端口上监听的客户端/服务器，它实现了 BitTorrent 协议
- “node” 是在一个 UDP 端口上监听的客户端/服务器，它实现了 DHT协议

### IPFS 协议

星际文件系统（InterPlanetary File System，简称IPFS）是一个基于内容寻址的、分布式的、新型超媒体传输协议。IPFS支持创建完全分布式的应用。它旨在使网络更快、更安全、更开放。IPFS是一个分布式文件系统，它的目标是将所有计算设备连接到同一个文件系统，从而成为一个全球统一的存储系统。IPFS项目通过整合已有的技术（BitTorrent、DHT/Kademlia、Git和SFS），创建一种P2P超媒体协议，试图打造一个更加快速、安全、开放的下一代互联网，实现互联网中永久可用、数据可以永久保存的全球文件存储系统。IPFS工作原理如下：

- 每个文件及其中的所有块都被赋予一个称为加密散列的唯一指纹。
- IPFS通过网络删除重复具有相同哈希值的文件，通过计算是可以判断哪些文件是冗余重复的。并跟踪每个文件的版本历史记录。
- 每个网络节点只存储它感兴趣的内容，以及一些索引信息，有助于弄清楚谁在存储什么。
- 查找文件时，你通过文件的哈希值就可以在网络查找到储存改文件的节点，找到想要的文件。
- 使用称为IPNS（去中心化命名系统），每个文件都可以被协作命名为易读的名字。通过搜索，就能很容易地找到想要查看的文件。



# 分布式哈希表

## 从哈希表到分布式哈希表

### 哈希表

哈希表（Hash Table，也叫散列表），是根据关键码值而直接进行访问的数据结构。也就是说它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。在散列表这种数据结构中，会包含 N 个 Bucket（桶）。对于某个具体的散列表，N（桶的数量）通常是固定不变的，于是可以对每个桶进行编号，从 0 到 N-1。桶是用来存储键值对的，可以把它通俗理解成一个动态数组，里面可以存放多个键值对。

过程简述为，利用Hash Table和Hash Function将Key和Data(即Value)映射到Hash Bucket中：

- Key经过Hash Function后算出Bucket位置，再Data存入
- 之后透过相同的Key可以在O(1)内得出Bucket位置

[![gDiESx.png](https://z3.ax1x.com/2021/05/13/gDiESx.png)](https://imgtu.com/i/gDiESx)

### 分布式哈希表

DHT的概念便是把上述的Bucket实例化为各个存储节点，此时分布式的特征在此体现。

- Key经过Hash Function后算出Data应该存储在哪个结点
- 流量请求和Data可以被分散至不同的结点上

[![gDiVl6.png](https://z3.ax1x.com/2021/05/13/gDiVl6.png)](https://imgtu.com/i/gDiVl6)



## DHT详解

分布式散列表的结构可以分成几个主要的组件。其基础是一个抽象的`键空间`（Keyspace），例如说所有160位长的字符串集合。`键空间分区`（Keyspace partitioning）将`键空间`分区成数个，并指定到在此系统的节点中。而`延展网络`则连接这些节点，并让他们能够借由在`键空间`内的任一值找到拥有该值的节点。

假设`键空间`是一个160位长的字符串集合。为了在分布式散列表中存储一个文件，名称为`filename`且内容为`data`，我们计算出`filename`的SHA-1散列值——一个160位的键`key`——并将消息`put(key,data)`送给分布式散列表中的任意参与节点。此消息在延展网络中被路由，直到抵达在键空间分区中被指定负责存储关键值`key`的节点。而`(key,data)`即存储在该节点。其他的节点只需要重新计算`filename`的散列值`key`，然后提交消息`get(key)`给分布式哈希表中的任意参与节点，以此来找与`key`相关的数据。此消息也会在延展网络中被路由到负责存储`key`的节点。而此节点则会负责传回存储的数据`data`。

[![gDFng0.png](https://z3.ax1x.com/2021/05/13/gDFng0.png)](https://imgtu.com/i/gDFng0)

### 地址管理

上文提到，在分布式哈希表中，每个节点和资源都有一个唯一标识，通常是一个 160 位整数。为方便起见，我们称节点的唯一标识为 ID，称资源的唯一标识为 Key。我们可以把一个节点的 IP 地址用 SHA-1 算法哈希得到这个节点的 ID；同样地，把一个资源文件用 SHA-1 算法哈希就能得到这个资源的 Key 了。定义好 ID 和 Key 之后，就可以发布和存储资源了。每个节点都会负责一段特定范围的 Key，其规则取决于具体的算法。

发布和请求资源有两种做法，一种是直接把文件传输给负责的节点，由它存储文件资源；请求资源时再由这个节点将文件传输给请求者。另一种做法是由发布者自己设法存储资源，发布文件时把文件所在节点的地址传输给负责的节点，负责的节点仅存储一个地址；请求资源的时候会联系负责的节点获取资源文件的地址，然后再取回资源。

### 路由算法

#### 拓扑结构设计

DHT是分布式系统的实现，必然要定义某种拓扑结构，因此要设计路由算法。当某个分布式系统具有自己的拓扑结构，它本身成为一个覆盖网络。覆盖网络，通俗地说就是“网络之上的网络”。对于大部分 DHT 而言，它们是基于互联网之上的覆盖网络，它们的数据通讯是依赖下层的互联网来实现的。前面提到的结点ID，体现在分布式系统在设计拓扑结构和路由算法时，只需要考虑结点ID，而不用考虑其下层网络的属性（比如：协议类型、IP 地址、端口号）。

#### 路由算法实现

首先每个节点会由若干个其他节点的联系方式(IP 地址, 端口)，称之为路由表。一般来说一个有着 n个节点的分布式哈希表中，一个节点的路由表的长度为O(log⁡n)。每个节点都会按照特定的规则构建路由表，最终所有的节点会形成一张网络。从一个节点发出的消息会根据特定的路由规则，沿着网络逐步接近目标节点，最终达到目标节点。在有着 n 个节点的分布式哈希表中，这个过程的转发次数通常为O(log⁡n) 次。

#### 距离算法

某些 DHT 系统还会定义一种距离算法，用来计算：“节点之间的距离”、“数据之间的距离”、“节点与数据的距离”。此处所说的“距离”属于逻辑层面，对应的是 DHT 自己的拓扑结构，它与物理上的地理位置无关，也与互联网的拓扑结构无关。

### 自我组织

分布式哈希表中的节点都是由各个用户组成，随时有用户加入，离开或失效；并且分布式哈希表没有中央服务器，也就是说着这个系统完全没有管理者。这意味着分配地址，构建路由表、节点加入、节点离开，排除失效节点等操作都要靠自我组织策略实现。

要发布或获取资源首先要有节点加入，一个节点加入通常有以下几步。首先，一个新节点需要通过一些外部机制联系分布式哈希表中的任意一个已有节点；接着新节点通过请求这个已有节点构造出自己的路由表，并且更新其他需要与其建立连接的节点的路由表；最后这个节点还需要取回它所负责的资源。

------

**Reference/参考**: 

1. [Distributed hash table](https://en.wikipedia.org/wiki/Distributed_hash_table)
2. [Kademlia、DHT、KRPC、BitTorrent 协议、DHT Sniffer](https://blog.csdn.net/weixin_34297704/article/details/85881799)
3. [聊聊分布式散列表（DHT）的原理——以 Kademlia（Kad）](https://www.jianshu.com/p/ea322f256c24)

